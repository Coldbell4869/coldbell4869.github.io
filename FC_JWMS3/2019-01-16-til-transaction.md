---
layout: post
title: 트랜잭션
tags:
  - TIL/Java
---
## 트랜잭션

만약 출금기능을 만든다면?  
`출금(계좌, 금액)`

* 출금 이라는 ::비즈니스 메소드::의 절차가 있을 때
1. 잔액조회 (SELECT)
2. 잔액 - 금액 수정 (UPDATE) 
3. 로그 (INSERT)  
   // 만약 로그 기록에 실패하면 금액 수정 전으로 되돌려야함(ROLLBACK)

중간에 실패하면 ROLLBACK(원상복구)을 하고  
몽땅 성공하면 COMMIT(반영) 을 하게 됨

-> 이러한 일련의 과정을 **트랜잭션(transaction)**이라고 한다.  
트랜잭션은 *하나의 논리적인 작업 단위* 를 뜻한다.


> 게시판이 해야하는 일들을 생각해보면..
* 목록 읽어온다
* 페이지 읽어온다
* 상세정보를 읽어온다
등등 .. 여러 기능이 있는데 이러한 기능 하나하나가 트랜잭션으로..

    상세정보 읽어오기 :  
  1. 게시물 읽어온다.
  2. 조회수를 증가시킨다.

> 즉, 업무 로직이 복잡할수록 하나의 트랜잭션에서 처리해야 할 일이 많아진다

비즈니스 메소드 안에서 계산이 일어난다던지,  
DB에 select, update, insert, delete가 일어난다던지.. 여러가지 일들이 일어난다.


---
 
`중복된 객체나 코드는 별도의 객체나 메소드로 뽑아내야 함`

상품에 대한 정보를 읽어오고 조회수를 증가하는 것.

키워드:
* ::레이어드 아키텍처:: 
* 서비스 , 
* 비즈니스 레이어, 
* DAO

서블릿이 주로 하는 일 : 브라우저가 넘긴 값을 받아서 처리해서 출력하는 일.  
파라미터를 읽어서 결과를 출력하기.

비즈니스 로직이 수행되는 부분은 중복을 제거하려면 별도의 객체를 가져야 한다.  
그 별도의 객체로 우리는 DAO를 썼었음.

각각의 비즈니스 로직은 좀 더 큰 범위에서 서비스 로직으로 정의할 수 있음.  
서비스 로직은 여러개의 비즈니스 로직을 품는다는 느낌..?

각각의 비즈니스 레이어가 명확하지 않고 섞여있으면 잘못돼있는것이다.

면접질문 : ::레이어드 아키텍처에 대해 설명하시오::

[다층 구조 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%B8%B5_%EA%B5%AC%EC%A1%B0)

---
mysql은 기본적으로 AUTO_COMMIT임. 디폴트가 자동 커밋임.

SELECT @@AUTOCOMMIT; 으로 오토커밋 상태 확인가능

오토커밋을 끄면 수동커밋 할 수 있음.  
커밋 전에는 실제 DB에는 반영되지 않고 보여지는 화면에서만 반영됨.  
커밋하면 실제 DB에 반영됨.  
 
트랜잭션이 커밋 또는 되기 전까지는 해당 연결에서만 저장(반영)된것처럼 보이는 것 뿐임.  

하나의 트랜잭션은 하나의 커넥션 안에서 이루어져야 함.  
그러나 우리는 매번 다시 커넥션을 함.  
트랜잭션 처리가 될려면 이렇게 짜면 안됨.  

하나의 커넥션 안에서 하나의 트랜잭션이 이루어지도록 한 이유는  
각각의 트랜잭션을 보호하기 위함이기도 함  
한 커넥션의 조회수+1의 업데이트와 커밋(롤백)이 끝나기 전에 다른 커넥션에서 업데이트  
커밋이 필요해지더라도 먼저 들어온 커넥션의 트랜잭션이 끝나야 실시되기 때문에 먼저 들어온  쪽이나 나중에 들어온 쪽의 조회수+1 업데이트가 씹힐 일이 없음.  

대신 각 커넥션의 트랜잭션이 커밋(롤백)되기까지의 시간을 빠르게 해야 함.  
하나가 느려지면 대기하고있는 다른 커넥션과 트랜잭션도 전부 느려서 밀리기 때문.

원인은 느린 SQL문을 사용한다던가 커밋(롤백)이 안되는 경우 등 여러 케이스가 있음.


connectioncontexholder 라는 보관함에서 넣고 빼고를 자유롭게 할 것임.  
[thread local 사용방법과 예제](https://www.baeldung.com/java-threadlocal)

프로그래머가 트랜잭션 관리를 하는 불편함을 해결해주는게 Spring 이다.

DAO와 서비스 객체는 동시에 호출해도 문제가 없기때문에 메모리에 하나만 있어도 상관없음.  
그래서 DAO랑 서비스는 싱글턴으로 만들어도 됨.  
객체는 되도록이면 많이 생성할 필요가 없다.

---

## 비즈니스로직
출금을 하기 위해서 여러 단계가 있고, 이 단계를 모두 성공해야 커밋임.  
중간에 하나라도 실패하면 롤백을 시켜야 함.

프로그램을 만들 때 어떤 로직을 고민해보세요 라고 하면  
하나의 트랜잭션 단위로 동작하는 로직, 서비스메소드 에 대해 고민해야 함.   
어떤 로직을 만들까 어떤 비즈니스메소드를 만들까...  
트랜잭션 단위로 동작하도록 하는 코드에 대해 고민해야 함.  
트랜잭션 처리는 커넥션 객체와 깊은 관련이 있다.  
set autocommit() 메소드 디폴트는 오토커밋상태이기때문에  
우리는 오토커밋을 false로 바꿔줬고  
작업이 다 성공하면 commit, 아니면 rollback을 했음.  
select만 할 경우에는 여러줄을 실행해도  
commit이나 rollback을 할 일이 없다. 셀렉트는 데이터의 상태를 변화시키는게 아니니깐.

서비스단에서 커넥션을 얻었고 DAO에서 커넥션이 필요한데  
다오 메소드 안에서 ps,rs가 필요할때 커넥션이 필요한데 그때 새로 만드는게 아니라  
서비스단에서 만들어진 커넥션을 다오에서 사용하기 위해서 ThreadLocal이라는 객체가 사용됨.  

오늘 용어들을 찾아보고 정리해야 함.  

### 숙제
**용어들에 대해 정리하기.**
* 트랜젝션
* Thread Pool
* ThreadLocal

나중에는 자동으로 심플한 코드로 하는 방법에 대해 배울것임.  
오늘 배운 내용은 별 20개짜리 중요한 내용임.  
이 개념을 이해해야 앞으로 다음에 배울 내용에 대해 이해할 수 있음.  

framework을 사용하지 않고 만들고있는 이 게시판을 Spring으로 조금씩 바꿀것임.  
코드를 어떻게 수정했는지 기억해야함(최종 완성본만 기억하지 말고!)  
어떻게 조금씩 추가했는지 기록해둬라.  

DAO , DBUtil 클래스들이 만들어지는 과정..?  

깃헙에 태그를 이용해서 스냅샷을 남길 수 있으니 혼자 개발할때도 도움이 됨.   
과거 그 상태의 코드를 받아올 수 있음.  
오늘버전/어제버전/그저께버전을 다 받아서 따로 관리해볼 수 있음.  
git을 사용하면 그게 가능하니깐 git도 열심히 공부하란 말씀..



